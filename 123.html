<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word内容控件编辑器（Base64图片修复版）</title>
    <!-- 引入外部资源 -->
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    <script src="C:\Users\L-pengbingguang\Desktop\jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">

    <style>
        /* 保持原有样式 */
        body {
            margin: 0;
            padding: 0;
            background-color: #f5f7fa;
        }

        .app-container {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .upload-area {
            background: white;
            padding: 20px;
            border-radius: 4px;
            margin-bottom: 20px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
        }

        .main-content {
            display: flex;
            gap: 20px;
        }

        .control-panel {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 160px);
            display: flex;
            flex-direction: column;
        }

        .preview-panel {
            flex: 2;
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
            max-height: calc(100vh - 160px);
            display: flex;
            flex-direction: column;
        }

        .controls-list {
            overflow-y: auto;
            flex: 1;
            margin-top: 15px;
        }

        .control-item {
            padding: 15px;
            border: 1px solid #eaeaea;
            border-radius: 4px;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

            .control-item:hover {
                border-color: #409EFF;
                box-shadow: 0 0 10px rgba(64, 158, 255, 0.2);
            }

        .preview-content {
            flex: 1;
            overflow-y: auto;
            margin-top: 15px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        .content-control {
            background-color: #e6f7ff;
            padding: 0 5px;
            border-bottom: 2px solid #1890ff;
            border-radius: 2px;
        }

        .content-control-image {
            border: 2px dashed #1890ff;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: inline-block;
        }

        .image-preview {
            max-width: 100%;
            max-height: 200px;
            margin-top: 10px;
            border-radius: 4px;
        }

        .footer-actions {
            margin-top: 15px;
            text-align: right;
        }

        .control-type-badge {
            margin-left: 10px;
            font-size: 12px;
            padding: 2px 6px;
        }

        .debug-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 3px;
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

            ::-webkit-scrollbar-thumb:hover {
                background: #a8a8a8;
            }
    </style>
</head>
<body>
    <div id="app">
        <el-container>
            <el-header style="background-color: #1890ff; color: white; padding: 0 20px;">
                <div style="display: flex; align-items: center; height: 100%;">
                    <i class="fa fa-file-word-o" style="font-size: 20px; margin-right: 10px;"></i>
                    <h1 style="margin: 0; font-size: 18px;">Word内容控件编辑器（Base64图片修复版）</h1>
                </div>
            </el-header>

            <el-main>
                <div class="app-container">
                    <!-- 上传区域 -->
                    <div class="upload-area">
                        <el-upload class="upload-demo"
                                   action=""
                                   :auto-upload="false"
                                   :on-change="handleFileChange"
                                   :show-file-list="false"
                                   :before-upload="beforeUpload">
                            <el-button size="medium" type="primary">
                                <i class="fa fa-upload"></i> 选择Word文档
                            </el-button>
                            <div style="margin-top: 10px;">
                                <el-tag v-if="fileName" type="info">{{ fileName }}</el-tag>
                                <span class="el-upload__tip" style="margin-left: 10px;">支持.docx格式的Word文档</span>
                            </div>
                        </el-upload>

                        <div style="margin-top: 15px; border: 2px dashed #ddd; border-radius: 4px; padding: 30px; text-align: center; cursor: pointer;"
                             @click="triggerUpload"
                             @dragover.prevent
                             @dragenter.prevent
                             @drop.prevent="handleDrop">
                            <i class="fa fa-cloud-upload" style="font-size: 48px; color: #999; margin-bottom: 10px;"></i>
                            <p style="color: #666;">拖放.docx文件到此处上传</p>
                        </div>

                        <!-- 调试信息 -->
                        <div v-if="debugInfo.length" class="debug-info" style="margin-top: 15px; max-height: 100px; overflow-y: auto;">
                            <p style="margin: 0 0 5px 0; font-weight: bold;">调试信息:</p>
                            <p v-for="(info, i) in debugInfo" :key="i" style="margin: 0 0 2px 0;">{{ info }}</p>
                        </div>
                    </div>

                    <!-- 主内容区 -->
                    <div class="main-content" v-if="isDocumentLoaded">
                        <!-- 左侧控制面板 -->
                        <div class="control-panel">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <el-card-header style="padding: 0;">
                                    <el-button type="success"
                                               size="mini"
                                               @click="applyAllChanges"
                                               :loading="isProcessing">
                                        <i class="fa fa-check"></i> 应用所有更改
                                    </el-button>
                                </el-card-header>
                                <el-badge :value="contentControls.length" type="primary">
                                    内容控件
                                </el-badge>
                            </div>

                            <div class="controls-list">
                                <div v-if="contentControls.length === 0" style="text-align: center; padding: 20px; color: #999;">
                                    <i class="fa fa-search" style="font-size: 32px; margin-bottom: 10px;"></i>
                                    <p>未找到内容控件</p>
                                </div>

                                <!-- 文本内容控件 -->
                                <div v-for="(control, index) in contentControls"
                                     :key="control.id"
                                     class="control-item"
                                     v-if="!control.isImage">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <span>内容控件</span>
                                        <el-badge type="primary" class="control-type-badge">文本</el-badge>
                                    </div>

                                    <el-descriptions column="1" border>
                                        <el-descriptions-item label="控件ID">
                                            <el-tag type="primary">{{ control.id }}</el-tag>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="别名(Alias)">
                                            <el-tag type="info">{{ control.alias }}</el-tag>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="标签(Tag)">
                                            <el-tag type="warning">{{ control.tag }}</el-tag>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="内容">
                                            <el-input type="textarea"
                                                      :rows="3"
                                                      v-model="control.content"
                                                      placeholder="请输入内容..."></el-input>
                                        </el-descriptions-item>
                                    </el-descriptions>
                                    <div style="text-align: right; margin-top: 10px;">
                                        <el-button type="success"
                                                   size="mini"
                                                   @click="applyChange(index)"
                                                   :loading="isProcessing">
                                            <i class="fa fa-check"></i> 应用
                                        </el-button>
                                    </div>
                                </div>

                                <!-- 图片内容控件 -->
                                <div v-for="(control, index) in contentControls"
                                     :key="control.id"
                                     class="control-item"
                                     v-if="control.isImage">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                        <span>内容控件</span>
                                        <el-badge type="success" class="control-type-badge">图片</el-badge>
                                    </div>

                                    <el-descriptions column="1" border>
                                        <el-descriptions-item label="控件ID">
                                            <el-tag type="primary">{{ control.id }}</el-tag>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="别名(Alias)">
                                            <el-tag type="info">{{ control.alias }}</el-tag>
                                        </el-descriptions-item>
                                        <el-tag type="info" style="margin-left: 10px;">
                                            {{ control.imageFileName || '未知图片' }}
                                        </el-tag>
                                        <el-descriptions-item label="Base64状态">
                                            <el-tag :type="control.base64Status === '成功' ? 'success' : 'danger'">
                                                {{ control.base64Status }}
                                            </el-tag>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="当前图片">
                                            <div v-if="control.imageUrl" class="image-preview-container">
                                                <img :src="control.imageUrl" class="image-preview" :alt="control.alias || '图片预览'">
                                            </div>
                                            <div v-else class="text-gray-500 text-sm">
                                                <i class="fa fa-exclamation-triangle text-orange-500"></i> 无法预览图片
                                                <div v-if="control.debugInfo" class="debug-info">
                                                    {{ control.debugInfo }}
                                                </div>
                                            </div>
                                        </el-descriptions-item>
                                        <el-descriptions-item label="更换图片">
                                            <el-upload class="avatar-uploader"
                                                       action=""
                                                       :auto-upload="false"
                                                       :on-change="(file) => handleImageUpload(file, index)"
                                                       :show-file-list="false"
                                                       accept="image/*">
                                                <el-button size="small" type="primary">
                                                    <i class="fa fa-picture-o"></i> 选择图片
                                                </el-button>
                                            </el-upload>
                                        </el-descriptions-item>
                                    </el-descriptions>
                                    <div style="text-align: right; margin-top: 10px;">
                                        <el-button type="success"
                                                   size="mini"
                                                   @click="applyChange(index)"
                                                   :loading="isProcessing"
                                                   :disabled="!control.imageChanged">
                                            <i class="fa fa-check"></i> 应用图片
                                        </el-button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 右侧预览面板 -->
                        <div class="preview-panel">
                            <el-card-header style="padding: 0;">
                                <el-tabs v-model="activeTab" type="card">
                                    <el-tab-pane label="文档预览" name="preview">
                                        <i class="fa fa-eye" style="margin-right: 5px;"></i>文档预览
                                    </el-tab-pane>
                                    <el-tab-pane label="媒体文件" name="media">
                                        <i class="fa fa-file-image-o" style="margin-right: 5px;"></i>媒体文件(Base64)
                                    </el-tab-pane>
                                </el-tabs>
                            </el-card-header>

                            <div class="preview-content" v-if="activeTab === 'preview'">
                                <div v-if="!previewHtml" style="text-align: center; padding: 50px 0; color: #999;">
                                    <i class="fa fa-file-text-o" style="font-size: 64px; margin-bottom: 20px;"></i>
                                    <p>修改内容后将在这里显示预览效果</p>
                                </div>
                                <div v-else v-html="previewHtml"></div>
                            </div>

                            <!-- 媒体文件标签页 - 显示所有转换为Base64的图片 -->
                            <div class="preview-content" v-if="activeTab === 'media'">
                                <el-table :data="mediaFileTableData"
                                          border
                                          style="width: 100%;"
                                          size="small">
                                    <el-table-column prop="fileName"
                                                     label="文件名"
                                                     width="180">
                                    </el-table-column>
                                    <el-table-column prop="path"
                                                     label="路径"
                                                     width="220">
                                    </el-table-column>
                                    <el-table-column prop="size"
                                                     label="大小"
                                                     width="100">
                                        <template slot-scope="scope">
                                            {{ (scope.row.size / 1024).toFixed(2) }} KB
                                        </template>
                                    </el-table-column>
                                    <el-table-column prop="status"
                                                     label="Base64转换"
                                                     width="120">
                                        <template slot-scope="scope">
                                            <el-tag :type="scope.row.status === '成功' ? 'success' : 'danger'">
                                                {{ scope.row.status }}
                                            </el-tag>
                                        </template>
                                    </el-table-column>
                                    <el-table-column prop="preview"
                                                     label="预览">
                                        <template slot-scope="scope">
                                            <img v-if="scope.row.base64Url"
                                                 :src="scope.row.base64Url"
                                                 style="max-width: 100px; max-height: 80px; border-radius: 4px;"
                                                 :alt="scope.row.fileName">
                                        </template>
                                    </el-table-column>
                                </el-table>
                            </div>

                            <div class="footer-actions">
                                <el-button type="primary"
                                           @click="downloadModifiedDocument"
                                           :loading="isProcessing">
                                    <i class="fa fa-download"></i> 下载修改后的文档
                                </el-button>
                            </div>
                        </div>
                    </div>

                    <!-- 初始状态提示 -->
                    <div v-else style="text-align: center; padding: 50px; background: white; border-radius: 4px; box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);">
                        <i class="fa fa-file-word-o" style="font-size: 80px; color: #ddd; margin-bottom: 20px;"></i>
                        <p style="color: #666; font-size: 16px;">请上传一个Word文档开始编辑</p>
                    </div>
                </div>
            </el-main>

            <el-footer style="text-align: center; color: #666; font-size: 12px;">
                所有操作均在本地完成，您的文档不会上传到服务器 | 基于Element UI构建
            </el-footer>
        </el-container>

        <!-- 加载中提示 -->
        <el-loading v-if="isProcessing"
                    text="处理中，请稍候..."
                    fullscreen
                    :background="'rgba(255, 255, 255, 0.8)'"></el-loading>

        <!-- 消息提示 -->
        <el-notification :title="notification.title"
                         :message="notification.message"
                         :type="notification.type"
                         :duration="3000"
                         v-if="notification.show"></el-notification>
    </div>

    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    // 文件相关
                    fileName: '',
                    originalZip: null,
                    documentXmlContent: '',
                    documentRelsContent: '',
                    relationships: {},
                    mediaFiles: {}, // 存储媒体文件 {filename: {base64: "...", size: ..., path: "..."}
                    mediaFileTableData: [], // 媒体文件表格数据
                    nextImageIndex: 1,
                    isDocumentLoaded: false,
                    isProcessing: false,

                    // 内容控件数据
                    contentControls: [],

                    // 预览相关
                    previewHtml: '',
                    activeTab: 'preview',

                    // 操作日志
                    operationLogs: [],

                    // 调试信息
                    debugInfo: [],

                    // 通知提示
                    notification: {
                        show: false,
                        title: '',
                        message: '',
                        type: ''
                    }
                };
            },
            methods: {
                // 处理文件选择
                handleFileChange(file) {
                    this.debugInfo = [];
                    this.processFile(file.raw);
                },

                // 处理拖放文件
                handleDrop(e) {
                    this.debugInfo = [];
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        this.processFile(file);
                    }
                },

                // 添加调试信息
                addDebugInfo(message) {
                    this.debugInfo.push(`[${new Date().toLocaleTimeString()}] ${message}`);
                    console.log(`调试: ${message}`);
                },

                // 触发上传
                triggerUpload() {
                    document.querySelector('.el-upload__input').click();
                },

                // 上传前校验
                beforeUpload(file) {
                    const isDocx = file.name.endsWith('.docx');
                    if (!isDocx) {
                        this.showNotification('请上传.docx格式的Word文档', 'warning');
                    }
                    return isDocx;
                },

                // 解析关系文件
                parseRelationships(relsXml) {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(relsXml, "application/xml");
                        const relationships = doc.getElementsByTagName("Relationship");
                        const idToPath = {};

                        for (let i = 0; i < relationships.length; i++) {
                            const rel = relationships[i];
                            const id = rel.getAttribute("Id");
                            const type = rel.getAttribute("Type");
                            const target = rel.getAttribute("Target");

                            if (type && type.includes("image")) {
                                idToPath[id] = target;
                                this.addDebugInfo(`解析图片关系: ${id} → ${target}`);
                            }
                        }

                        return idToPath;
                    } catch (error) {
                        this.addDebugInfo(`解析关系文件出错: ${error.message}`);
                        return {};
                    }
                },

                // 处理文件并提取内容控件
                async processFile(file) {
                    if (!file.name.endsWith('.docx')) {
                        this.showNotification('请上传.docx格式的Word文档', 'warning');
                        return;
                    }

                    try {
                        this.isProcessing = true;
                        this.fileName = file.name;
                        this.addDebugInfo(`开始处理文件: ${file.name}`);

                        // 读取文件并解压
                        const arrayBuffer = await this.readFileAsArrayBuffer(file);
                        const zip = await JSZip.loadAsync(arrayBuffer);
                        this.originalZip = zip;
                        this.addDebugInfo('文件解压成功');

                        // 读取document.xml内容
                        const docXmlFile = zip.file('word/document.xml');
                        if (!docXmlFile) {
                            throw new Error('文档结构不正确，未找到word/document.xml');
                        }
                        this.documentXmlContent = await docXmlFile.async('text');
                        this.addDebugInfo('已读取word/document.xml');

                        // 读取并解析document.xml.rels内容
                        const relsFile = zip.file('word/_rels/document.xml.rels');
                        if (relsFile) {
                            this.documentRelsContent = await relsFile.async('text');
                            this.addDebugInfo('已读取word/_rels/document.xml.rels');
                            this.relationships = this.parseRelationships(this.documentRelsContent);
                        } else {
                            this.addDebugInfo('警告: 未找到word/_rels/document.xml.rels');
                            this.relationships = {};
                        }

                        // 收集媒体文件并强制转换为Base64 - 核心修复点
                        this.mediaFiles = {};
                        this.mediaFileTableData = [];
                        const mediaFiles = zip.file(/word\/media\//i);
                        this.addDebugInfo(`找到 ${mediaFiles.length} 个媒体文件`);

                        for (const mediaFile of mediaFiles) {
                            const fullPath = mediaFile.name; // 完整路径如word/media/image1.png
                            const fileName = fullPath.replace(/^word\/media\//i, ''); // 提取文件名如image1.png

                            try {
                                // 强制读取为Base64，不依赖路径解析
                                const base64Data = await mediaFile.async('base64');
                                const fileSize = await mediaFile.async('uint8array').then(arr => arr.length);

                                // 存储Base64数据和文件信息
                                this.mediaFiles[fileName] = {
                                    base64: base64Data,
                                    size: fileSize,
                                    path: fullPath,
                                    base64Url: `data:image/*;base64,${base64Data}`
                                };

                                // 添加到媒体文件表格
                                this.mediaFileTableData.push({
                                    fileName,
                                    path: fullPath,
                                    size: fileSize,
                                    status: "成功",
                                    base64Url: `data:image/*;base64,${base64Data}`
                                });

                                this.addDebugInfo(`已将 ${fullPath} 转换为Base64，大小: ${(fileSize / 1024).toFixed(2)}KB`);
                            } catch (e) {
                                this.addDebugInfo(`转换 ${fullPath} 为Base64失败: ${e.message}`);
                                this.mediaFileTableData.push({
                                    fileName,
                                    path: fullPath,
                                    size: 0,
                                    status: "失败",
                                    base64Url: null
                                });
                            }
                        }

                        // 提取内容控件
                        this.extractContentControls();

                        // 生成初始预览
                        this.generatePreview();

                        this.isDocumentLoaded = true;
                        this.showNotification('文档加载成功，已将媒体文件转换为Base64', 'success');
                        this.addOperationLog('文档加载成功', 'success', 'fa-file-text-o');
                    } catch (error) {
                        console.error('处理文件出错:', error);
                        this.addDebugInfo(`处理失败: ${error.message}`);
                        this.showNotification(`处理失败: ${error.message}`, 'error');
                    } finally {
                        this.isProcessing = false;
                    }
                },

                // 提取内容控件 - 重点使用Base64显示图片
                extractContentControls() {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(this.documentXmlContent, 'text/xml');

                    // 命名空间解析器
                    const nsResolver = (prefix) => {
                        const ns = {
                            'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
                            'r': 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
                            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
                        };
                        return ns[prefix] || null;
                    };

                    // 查找所有内容控件
                    const xpath = "//w:sdt";
                    const result = xmlDoc.evaluate(xpath, xmlDoc, nsResolver, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);

                    const controls = [];
                    let node;
                    let controlCount = 0;

                    while (node = result.iterateNext()) {
                        controlCount++;
                        const sdtPr = node.querySelector('w\\:sdtPr, sdtPr');
                        if (!sdtPr) continue;

                        // 提取ID
                        const idNode = sdtPr.querySelector('w\\:id, id');
                        const id = idNode ? idNode.getAttribute('w:val') : `auto-id-${controlCount}`;

                        // 判断是否为图片内容控件
                        const isImage = sdtPr.querySelector('w\\:picture, picture') !== null;
                        this.addDebugInfo(`控件 ${controlCount}: ID=${id}, 类型=${isImage ? '图片' : '文本'}`);

                        // 提取别名和标签
                        const aliasNode = sdtPr.querySelector('w\\:alias, alias');
                        const alias = aliasNode ? aliasNode.getAttribute('w:val') : '';
                        const tagNode = sdtPr.querySelector('w\\:tag, tag');
                        const tag = tagNode ? tagNode.getAttribute('w:val') : '';

                        // 初始化控件数据
                        const controlData = {
                            id,
                            alias,
                            tag,
                            isImage,
                            imageUrl: null,       // Base64图片URL
                            imageData: null,      // Base64数据
                            imageRelId: null,     // 关系ID
                            imageFileName: null,  // 图片文件名
                            base64Status: "未尝试", // Base64转换状态
                            imageChanged: false,
                            content: '',
                            debugInfo: ''
                        };

                        // 处理图片控件 - 强制使用Base64
                        if (isImage) {
                            debugger;
                            let debugMsgs = [];
                            const sdtContent = node.querySelector('w\\:sdtContent, sdtContent');

                            if (sdtContent) {
                                // 查找图片引用节点
                                let blipNode = sdtContent.querySelector('a\\:blip, blip');

                                if (blipNode) {
                                    // 获取关系ID
                                    controlData.imageRelId = blipNode.getAttribute('r:embed') ||
                                        blipNode.getAttribute('embed');
                                    debugMsgs.push(`图片引用ID: ${controlData.imageRelId}`);

                                    // 查找图片文件名
                                    if (controlData.imageRelId && this.relationships[controlData.imageRelId]) {
                                        const targetPath = this.relationships[controlData.imageRelId];
                                        controlData.imageFileName = targetPath.split('/').pop().split('\\').pop();
                                        debugMsgs.push(`通过关系找到图片: ${targetPath} → 文件名=${controlData.imageFileName}`);
                                    }

                                    // 尝试通过文件名直接获取Base64数据 - 核心修复点
                                    if (controlData.imageFileName) {
                                        // 不区分大小写查找图片文件
                                        const lowerFileName = controlData.imageFileName.toLowerCase();
                                        const matchedFile = Object.keys(this.mediaFiles).find(
                                            key => key.toLowerCase() === lowerFileName
                                        );

                                        if (matchedFile && this.mediaFiles[matchedFile].base64) {
                                            // 直接使用预转换的Base64数据
                                            controlData.imageUrl = this.mediaFiles[matchedFile].base64Url;
                                            controlData.imageData = this.mediaFiles[matchedFile].base64;
                                            controlData.base64Status = "成功";
                                            debugMsgs.push(`成功加载Base64图片: ${matchedFile}`);
                                        } else {
                                            controlData.base64Status = "失败";
                                            debugMsgs.push(`未找到Base64数据: ${controlData.imageFileName}`);
                                            debugMsgs.push(`可用图片文件: ${Object.keys(this.mediaFiles).join(', ')}`);
                                        }
                                    } else {
                                        controlData.base64Status = "失败";
                                        debugMsgs.push(`无法确定图片文件名`);
                                    }
                                } else {
                                    controlData.base64Status = "失败";
                                    debugMsgs.push(`未找到图片引用节点(a:blip)`);
                                }
                            } else {
                                controlData.base64Status = "失败";
                                debugMsgs.push(`未找到sdtContent节点`);
                            }

                            controlData.debugInfo = debugMsgs.join('; ');
                        }
                        // 处理文本控件
                        else {
                            const sdtContent = node.querySelector('w\\:sdtContent, sdtContent');
                            if (sdtContent) {
                                const textNodes = sdtContent.querySelectorAll('w\\:t, t');
                                if (textNodes.length > 0) {
                                    controlData.content = Array.from(textNodes).map(n => n.textContent).join('');
                                }
                            }
                        }

                        controls.push(controlData);
                    }

                    this.addDebugInfo(`共找到 ${controls.length} 个内容控件`);
                    this.contentControls = controls;
                },

                // 生成预览HTML
                generatePreview() {
                    let html = '<div class="word-preview">';

                    // 提取段落内容
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(this.documentXmlContent, 'text/xml');
                    const paragraphs = xmlDoc.querySelectorAll('w\\:p, p');

                    paragraphs.forEach(para => {
                        let paraText = '';

                        // 处理普通文本节点
                        const textNodes = para.querySelectorAll('w\\:t:not(w\\:sdt w\\:t), t:not(sdt t)');
                        textNodes.forEach(textNode => {
                            paraText += textNode.textContent;
                        });

                        // 处理内容控件
                        const contentControls = para.closest('w\\:sdt, sdt') ? [para.closest('w\\:sdt, sdt')] :
                            para.querySelectorAll('w\\:sdt, sdt');

                        contentControls.forEach(control => {
                            const sdtPr = control.querySelector('w\\:sdtPr, sdtPr');
                            if (!sdtPr) return;

                            const idNode = sdtPr.querySelector('w\\:id, id');
                            const id = idNode ? idNode.getAttribute('w:val') : '未知ID';
                            const isImage = sdtPr.querySelector('w\\:picture, picture') !== null;

                            if (isImage) {
                                const controlData = this.contentControls.find(c => c.id === id);

                                if (controlData && controlData.imageUrl) {
                                    paraText += `<div class="content-control-image" data-id="${id}">
                                    <img src="${controlData.imageUrl}" style="max-width: 300px; max-height: 200px;"
                                         alt="${controlData.alias || '图片内容控件'}">
                                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                      ${controlData.imageFileName || '图片'}
                                    </div>
                                  </div>`;
                                } else {
                                    paraText += `<div class="content-control-image" data-id="${id}" style="min-width: 200px; min-height: 100px; text-align: center; line-height: 100px; color: #999;">
                                    [图片内容控件: ${id}]
                                    ${controlData && controlData.imageFileName ? `<div style="font-size: 10px;">文件: ${controlData.imageFileName}</div>` : ''}
                                  </div>`;
                                }
                            } else {
                                // 文本控件处理
                                let content = '[' + id + ']';
                                const sdtContent = control.querySelector('w\\:sdtContent, sdtContent');
                                if (sdtContent) {
                                    const ctrlTextNodes = sdtContent.querySelectorAll('w\\:t, t');
                                    if (ctrlTextNodes.length > 0) {
                                        content = Array.from(ctrlTextNodes).map(n => n.textContent).join('');
                                    }
                                }

                                paraText += `<span class="content-control" data-id="${id}">${content}</span>`;
                            }
                        });

                        if (paraText.trim()) {
                            html += `<p style="margin-bottom: 16px;">${paraText}</p>`;
                        }
                    });

                    html += '</div>';
                    this.previewHtml = html;
                },

                // 处理图片上传
                handleImageUpload(file, index) {
                    const control = this.contentControls[index];
                    if (!control || !control.isImage) return;

                    // 读取图片文件并转换为Base64
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const base64Data = e.target.result.split(',')[1];
                        this.$set(this.contentControls, index, {
                            ...control,
                            imageUrl: e.target.result,
                            imageData: base64Data,
                            base64Status: "成功",
                            imageChanged: true
                        });

                        this.showNotification('图片已加载为Base64，点击"应用图片"生效', 'info');
                    };

                    if (file.raw.type.startsWith('image/')) {
                        reader.readAsDataURL(file.raw);
                    } else {
                        this.showNotification('请上传图片文件', 'warning');
                    }
                },

                // 应用单个控件的更改
                applyChange(index) {
                    debugger
                    if (!this.originalZip) return;

                    const control = this.contentControls[index];
                    if (!control) return;

                    try {
                        this.isProcessing = true;

                        if (control.isImage) {
                            if (control.imageChanged && control.imageData) {
                                this.updateImageControlInXml(control);
                                this.showNotification(`已更新图片控件 ID: ${control.id}`, 'success');
                            } else {
                                this.showNotification('未更改图片或图片数据无效', 'warning');
                            }
                        } else {
                            this.updateTextControlInXml(control.id, control.content);
                            this.showNotification(`已更新文本控件 ID: ${control.id}`, 'success');
                        }

                        this.generatePreview();
                    } catch (error) {
                        console.error('更新内容控件出错:', error);
                        this.showNotification('更新失败，请重试', 'error');
                    } finally {
                        this.isProcessing = false;
                    }
                },

                // 应用所有更改
                applyAllChanges() {
                    if (!this.originalZip || this.contentControls.length === 0) return;

                    try {
                        this.isProcessing = true;
                        let changesApplied = false;

                        this.contentControls.forEach(control => {
                            if (control.isImage) {
                                if (control.imageChanged && control.imageData) {
                                    this.updateImageControlInXml(control);
                                    changesApplied = true;
                                }
                            } else {
                                this.updateTextControlInXml(control.id, control.content);
                                changesApplied = true;
                            }
                        });

                        if (changesApplied) {
                            this.generatePreview();
                            this.showNotification('所有更改已应用', 'success');
                        } else {
                            this.showNotification('没有需要应用的更改', 'info');
                        }
                    } catch (error) {
                        console.error('应用所有更改出错:', error);
                        this.showNotification('应用更改失败，请重试', 'error');
                    } finally {
                        this.isProcessing = false;
                    }
                },

                // 更新文本控件
                updateTextControlInXml(controlId, newContent) {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(this.documentXmlContent, 'text/xml');

                    const nsResolver = (prefix) => {
                        const ns = { 'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main' };
                        return ns[prefix] || null;
                    };

                    const xpath = `//w:sdt[.//w:id[@w:val="${controlId}"]]`;
                    const result = xmlDoc.evaluate(xpath, xmlDoc, nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                    const controlNode = result.singleNodeValue;

                    if (controlNode) {
                        const sdtContent = controlNode.querySelector('w\\:sdtContent, sdtContent');
                        if (sdtContent) {
                            // 清除现有文本节点
                            const textNodes = sdtContent.querySelectorAll('w\\:t, t');
                            textNodes.forEach(node => node.parentNode.removeChild(node));

                            // 添加新内容
                            if (newContent.trim()) {
                                let pNode = sdtContent.querySelector('w\\:p, p') ||
                                    xmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:p');
                                let rNode = pNode.querySelector('w\\:r, r') ||
                                    xmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:r');
                                const textNode = xmlDoc.createElementNS('http://schemas.openxmlformats.org/wordprocessingml/2006/main', 'w:t');

                                textNode.textContent = newContent;
                                rNode.appendChild(textNode);
                                pNode.appendChild(rNode);
                                sdtContent.appendChild(pNode);
                            }
                        }

                        // 更新XML内容
                        const serializer = new XMLSerializer();
                        this.documentXmlContent = serializer.serializeToString(xmlDoc);
                    }
                },

                // 更新图片控件
                updateImageControlInXml(control) {
                    // 1. 生成新图片文件名
                    const fileExt = control.imageUrl.split(';')[0].split('/')[1];
                    const newFileName = `image${this.nextImageIndex}.${fileExt}`;
                    this.nextImageIndex++;

                    // 2. 更新ZIP中的媒体文件
                    const imageBlob = this.base64ToBlob(control.imageData, `image/${fileExt}`);
                    this.originalZip.file(`word/media/${newFileName}`, imageBlob);
                    this.addDebugInfo(`已添加新图片文件: word/media/${newFileName}`);

                    // 3. 更新关系文件
                    this.updateRelationships(control, newFileName);

                    // 4. 更新document.xml中的图片引用
                    this.updateImageReferenceInDocument(control, newFileName);

                    // 5. 更新控件数据和媒体文件列表
                    const index = this.contentControls.findIndex(c => c.id === control.id);
                    if (index !== -1) {
                        this.$set(this.contentControls, index, {
                            ...control,
                            imageFileName: newFileName,
                            base64Status: "成功",
                            imageChanged: false,
                        });
                    }

                    // 更新媒体文件数据
                    this.mediaFiles[newFileName] = {
                        base64: control.imageData,
                        size: control.imageData.length * 0.75, // 近似计算
                        path: `word/media/${newFileName}`,
                        base64Url: control.imageUrl
                    };

                    this.mediaFileTableData.push({
                        fileName: newFileName,
                        path: `word/media/${newFileName}`,
                        size: control.imageData.length * 0.75,
                        status: "成功",
                        base64Url: control.imageUrl
                    });
                },

                // 更新关系文件
                updateRelationships(control, newFileName) {
                    if (!this.documentRelsContent) {
                        this.documentRelsContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>`;
                    }

                    const parser = new DOMParser();
                    const relsDoc = parser.parseFromString(this.documentRelsContent, 'text/xml');

                    let relNode;
                    if (control.imageRelId) {
                        relNode = relsDoc.querySelector(`Relationship[Id="${control.imageRelId}"]`) ||
                            relsDoc.querySelector(`*|Relationship[Id="${control.imageRelId}"]`);
                    }

                    if (!relNode) {
                        const newRelId = `rId${Math.floor(Math.random() * 1000)}`;
                        control.imageRelId = newRelId;
                        const ns = 'http://schemas.openxmlformats.org/package/2006/relationships';
                        relNode = relsDoc.createElementNS(ns, 'Relationship');
                        relNode.setAttribute('Id', newRelId);
                        relsDoc.documentElement.appendChild(relNode);
                    }

                    relNode.setAttribute('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image');
                    relNode.setAttribute('Target', `media/${newFileName}`);
                    this.relationships[control.imageRelId] = `media/${newFileName}`;

                    // 更新关系文件内容
                    const serializer = new XMLSerializer();
                    this.documentRelsContent = serializer.serializeToString(relsDoc);
                    this.originalZip.file('word/_rels/document.xml.rels', this.documentRelsContent);
                },

                // 更新文档中的图片引用
                updateImageReferenceInDocument(control, newFileName) {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(this.documentXmlContent, 'text/xml');

                    const nsResolver = (prefix) => {
                        const ns = {
                            'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main',
                            'a': 'http://schemas.openxmlformats.org/drawingml/2006/main'
                        };
                        return ns[prefix] || null;
                    };

                    // 查找图片引用节点
                    const xpath = `//w:sdt[.//w:id[@w:val="${control.id}"]]//a:blip`;
                    const result = xmlDoc.evaluate(xpath, xmlDoc, nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                    let blipNode = result.singleNodeValue;

                    if (!blipNode) {
                        const xpath2 = `//w:sdt[.//w:id[@w:val="${control.id}"]]//blip`;
                        const result2 = xmlDoc.evaluate(xpath2, xmlDoc, nsResolver, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                        blipNode = result2.singleNodeValue;
                    }

                    if (blipNode) {
                        if (blipNode.hasAttribute('r:embed')) {
                            blipNode.setAttribute('r:embed', control.imageRelId);
                        } else if (blipNode.hasAttribute('embed')) {
                            blipNode.setAttribute('embed', control.imageRelId);
                        } else {
                            blipNode.setAttribute('r:embed', control.imageRelId);
                        }
                    } else {
                        throw new Error('未找到图片引用节点');
                    }

                    // 更新XML内容
                    const serializer = new XMLSerializer();
                    this.documentXmlContent = serializer.serializeToString(xmlDoc);
                },

                // 下载修改后的文档
                async downloadModifiedDocument() {
                    if (!this.originalZip) return;

                    try {
                        this.isProcessing = true;
                        this.originalZip.file('word/document.xml', this.documentXmlContent);
                        const content = await this.originalZip.generateAsync({ type: 'blob' });

                        const url = URL.createObjectURL(content);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = this.fileName.replace('.docx', '_modified.docx');
                        document.body.appendChild(a);
                        a.click();

                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 0);

                        this.showNotification('文档已下载', 'success');
                    } catch (error) {
                        console.error('生成文档出错:', error);
                        this.showNotification('下载失败，请重试', 'error');
                    } finally {
                        this.isProcessing = false;
                    }
                },

                // Base64转Blob
                base64ToBlob(base64Data, contentType) {
                    const byteCharacters = atob(base64Data);
                    const byteArrays = [];

                    for (let offset = 0; offset < byteCharacters.length; offset += 512) {
                        const slice = byteCharacters.slice(offset, offset + 512);
                        const byteNumbers = new Array(slice.length);

                        for (let i = 0; i < slice.length; i++) {
                            byteNumbers[i] = slice.charCodeAt(i);
                        }

                        byteArrays.push(new Uint8Array(byteNumbers));
                    }

                    return new Blob(byteArrays, { type: contentType });
                },

                // 显示通知
                showNotification(message, type) {
                    this.notification = {
                        show: true,
                        title: type === 'success' ? '成功' : type === 'warning' ? '警告' : '错误',
                        message: message,
                        type: type
                    };

                    setTimeout(() => this.notification.show = false, 3000);
                },

                // 添加操作日志
                addOperationLog(message, type, icon) {
                    this.operationLogs.unshift({
                        time: new Date(),
                        message: message,
                        type: type,
                        icon: icon
                    });

                    if (this.operationLogs.length > 20) {
                        this.operationLogs.pop();
                    }
                },

                // 格式化时间
                formatTime(date) {
                    return date.toLocaleString();
                },

                // 读取文件为ArrayBuffer
                readFileAsArrayBuffer(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(reader.error);
                        reader.readAsArrayBuffer(file);
                    });
                }
            }
        });
    </script>
</body>
</html>
